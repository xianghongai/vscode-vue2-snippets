{
	"VueRouter Full Navigation Resolution Flow": {
		"prefix": "vueNavigation",
		"body": [
			"/**",
			" * 1. Navigation triggered.",
			" * 2. Call `beforeRouteLeave` guards in deactivated components.",
			" * 3. Call global `beforeEach` guards.",
			" * 4. Call `beforeRouteUpdate` guards in reused components.",
			" * 5. Call `beforeEnter` in route configs.",
			" * 6. Resolve async route components.",
			" * 7. Call `beforeRouteEnter` in activated components.",
			" * 8. Call global `beforeResolve` guards.",
			" * 9. Navigation confirmed.",
			" * 10. Call global `afterEach` hooks.",
			" * 11. DOM updates triggered.",
			" * 12. Call callbacks passed to `next` in `beforeRouteEnter` guards with instantiated instances.",
			" */"
		]
	},

	"import VueRouter": {
		"prefix": "importVueRouter",
		"body": ["import VueRouter from 'vue-router';$0"],
		"description": "import VueRouter\n"
	},

	"VueRouter Create the router instance": {
		"prefix": ["router", "newVueRouter"],
		"body": [
			"const ${1:router} = new VueRouter({",
			"\t${2:routes}",
			"});$0"
		],
		"description": "Create the router instance, The default is hash mode.\n"
	},

	"VueRouter Create the router instance (import)": {
		"prefix": "newVueRouter",
		"body": [
			"import Vue from 'vue';",
			"import VueRouter from 'vue-router';",
			"",
			"Vue.use(VueRouter);",
			"",
			"export const router = new VueRouter({",
			"\t${1:base: '${2:/}',}",
			"\t${3:mode: '${4:history}',}",
			"\troutes: [$0",
			"\t\t{ path: '/pathname', component: Feature }",
			"\t]",
			"});"
		],
		"description": "Base for Vue Router\n"
	},

	"VueRouter Create the router instance with HTML5 History Mode": {
		"prefix": "routerHistoryMode",
		"body": [
			"const ${1:router} = new VueRouter({",
			"\tmode: 'history',",
			"\t${2:routes}",
			"});$0"
		],
		"description": "Create the router instance with HTML5 History Mode\n"
	},

	"VueRouter Define routes": {
		"prefix": "routes",
		"body": [
			"const ${1:routes} = [",
			"\t{ path: '${2:/feature}', component: ${3:Feature} },",
			"\t{",
			"\t\tpath: '${4:/feature}',",
			"\t\tcomponent: ${5:Feature},",
			"\t\tchildren: [",
			"\t\t\t{",
			"\t\t\t\tpath: '${6:/feature}',",
			"\t\t\t\tcomponent: ${7:Feature},",
			"\t\t\t},",
			"\t\t],",
			"\t},",
			"];"
		],
		"description": "Define routes\n"
	},

	"VueRouter Define route": {
		"prefix": "route",
		"body": [
			"{ path: '${1:/feature/:id}', component: ${2:Feature} },"
		],
		"description": "Define route\n"
	},
	"VueRouter Define lazy loading route": {
		"prefix": "routeLazy",
		"body": [
			"{",
			"\tpath: '${1:pathName}',",
			"\tname: '${2:routeName}',",
			"\tcomponent: () => import('./${3:Feature}'),",
			"},"
		],
		"description": "Define lazy loading route\n"
	},
	"VueRouter Define route and pass props to route components (Boolean mode)": {
		"prefix": "routePropsBooleanMode",
		"body": [
			"{",
			"\tpath: '${1:/feature}',",
			"\tcomponent: ${2:Feature},",
			"\tprops: true,",
			"},$0"
		],
		"description": "When `props` is set to `true`, the `route.params` will be set as the component props.\n"
	},
	"VueRouter Define route and pass props to route components (Object mode)": {
		"prefix": "routePropsObjectMode",
		"body": [
			"{",
			"\tpath: '${1:/feature}',",
			"\tcomponent: ${2:Feature},",
			"\tprops: { ${3:property}: '${4:value}' },",
			"},$0"
		],
		"description": "\n"
	},
	"VueRouter Define route and pass props to route components (Function mode)": {
		"prefix": "routePropsFunctionMode",
		"body": [
			"{",
			"\tpath: '${1:/feature}',",
			"\tcomponent: ${2:Feature},",
			"\tprops: (route) => ($3{",
			"\t\tproperty: route.params.property,",
			"\t\tkey: route.query.key,",
			"\t}),",
			"},$0"
		],
		"description": "\n"
	},
	"VueRouter Define route and pass props for routes with named views (Function mode)": {
		"prefix": "routePropsFunctionModeNamedViews",
		"body": [
			"{",
			"\tpath: '${1:/feature}',",
			"\tcomponent: ${2:Feature},",
			"\tprops: {",
			"\t\tdefault: ${3:true},",
			"\t\t${4:viewName}: (route) => ($5{",
			"\t\t\tproperty: route.params.property,",
			"\t\t}),",
			"\t},",
			"},$0"
		],
		"description": "\n"
	},
	"VueRouter Define route for named views": {
		"prefix": "routeNamedViews",
		"body": [
			"{",
			"\tpath: '${1:/pathname}',",
			"\tcomponents: {",
			"\t\tdefault: ${2:Feature},",
			"\t\tview${3:Name}: ${3},",
			"\t},",
			"},"
		],
		"description": "\n"
	},
	"VueRouter Define alias route": {
		"prefix": "routeAlias",
		"body": [
			"{ path: '${1:/feature}', component: ${2:Feature}, alias: '{3:/feature}' },"
		],
		"description": "Define alias route\n"
	},

	"VueRouter Define redirect route": {
		"prefix": "routeRedirect",
		"body": [
			"{ path: '${1:/feature/:id}', redirect: '${2:/pathname}' },"
		],
		"description": "Define redirect route\nExample:\n// relative redirect to a sibling route\n`{ path: 'relative-redirect', redirect: 'feature' }`\n// absolute redirect\n`{ path: '/absolute-redirect', redirect: '/feature' },`\n// named redirect\n`{ path: '/named-redirect', redirect: { name: 'feature' }},`\n// redirect with params\n`{ path: '/redirect-with-params/:id', redirect: '/with-params/:id' },`\n"
	},
	"VueRouter Define redirect named route": {
		"prefix": "routeRedirectNamedRoute",
		"body": [
			"{ path: '${1:/feature/:id}', redirect: { name: '${2:routename}' }},"
		],
		"description": "Define redirect route\n"
	},
	"VueRouter Define dynamic redirect": {
		"prefix": "routeRedirectDynamic",
		"body": [
			"{",
			"\tpath: '/dynamic-redirect/:id?',",
			"\tredirect: (to) => {",
			"\t\tconst { hash, params, query } = to;",
			"\t\tif (query.property === 'value') {",
			"\t\t\treturn { path: '/pathname', query: null };",
			"\t\t}",
			"\t\tif (hash === '#feature') {",
			"\t\t\treturn { name: 'routename', hash: '' };",
			"\t\t}",
			"\t\tif (params.id) {",
			"\t\t\treturn '/with-params/:id';",
			"\t\t} else {",
			"\t\t\treturn '/feature';",
			"\t\t}",
			"\t},",
			"},"
		],
		"description": "Define dynamic redirect\n"
	},

	"VueRouter Define named route": {
		"prefix": "routeNamed",
		"body": [
			"{ path: '${1:/named-redirect}', name: '${2:feature}', component: ${3:Feature} },"
		],
		"description": "Define named route\n"
	},

	"VueRouter navigate to path with literal string": {
		"prefix": "routerPush",
		"body": ["${2:this.\\$}router.push('${1:pathname}');"],
		"description": "Router navigate to path.\n#syntax:\nrouter.push(location, onComplete?, onAbort?)\nrouter.push(location).then(onComplete).catch(onAbort)\n"
	},
	"VueRouter navigate to path": {
		"prefix": "routerPushPath",
		"body": [
			"${2:this.\\$}router.push({ path: '${1:pathname}' });"
		],
		"description": "Router navigate to path.\n#syntax:\nrouter.push(location, onComplete?, onAbort?)\nrouter.push(location).then(onComplete).catch(onAbort)\n"
	},
	"VueRouter navigate to path with params": {
		"prefix": "routerPushParams",
		"body": [
			"${5:this.\\$}router.push({",
			"\tpath: ${1:'${2:pathname}'},",
			"\tparams: { ${3:property}: ${4:'value'} },",
			"});"
		],
		"description": "Router navigate to path with params.\n#syntax:\nrouter.push(location, onComplete?, onAbort?)\nrouter.push(location).then(onComplete).catch(onAbort)\n"
	},
	"VueRouter navigate to path with query": {
		"prefix": "routerPushQuery",
		"body": [
			"${5:this.\\$}router.push({",
			"\tpath: ${1:'${2:pathname}'},",
			"\tquery: { ${3:property}: ${4:'value'} },",
			"});"
		],
		"description": "Router navigate to path with query.\n#syntax:\nrouter.push(location, onComplete?, onAbort?)\nrouter.push(location).then(onComplete).catch(onAbort)\n"
	},
	"VueRouter navigate to named routes": {
		"prefix": ["routerPushNamedRoute", "rpn"],
		"body": [
			"${2:this.\\$}router.push({ name: '${1:routename}' });"
		],
		"description": "Router navigate to named routes\n#syntax:\nrouter.push(location, onComplete?, onAbort?)\nrouter.push(location).then(onComplete).catch(onAbort)\n"
	},
	"VueRouter navigate to named routes with params": {
		"prefix": ["routerPushNamedRouteParams", "rpp"],
		"body": [
			"${5:this.\\$}router.push({",
			"\tname: ${1:'${2:routename}'},",
			"\tparams: { ${3:property}: ${4:'value'} },",
			"});"
		],
		"description": "Router navigate to named routes with params.\n#syntax:\nrouter.push(location, onComplete?, onAbort?)\nrouter.push(location).then(onComplete).catch(onAbort)\n"
	},
	"VueRouter navigate to named routes with query": {
		"prefix": ["routerPushNamedRouteQuery", "rpq"],
		"body": [
			"${5:this.\\$}router.push({",
			"\tname: ${1:'${2:routename}'},",
			"\tquery: { ${3:property}: ${4:'value'} },",
			"});"
		],
		"description": "Router navigate to named routes with query.\n#syntax:\nrouter.push(location, onComplete?, onAbort?)\nrouter.push(location).then(onComplete).catch(onAbort)\n"
	},
	"VueRouter navigate to path without pushing a new history entry": {
		"prefix": "routerReplacePath",
		"body": [
			"${5:this.\\$}router.replace({",
			"\tpath: ${1:'${2:pathname}'},",
			"\tparams: { ${3:property}: ${4:'value'} },",
			"});"
		],
		"description": "Router navigate to path without pushing a new history entry.\n#syntax:\nrouter.push(location, onComplete?, onAbort?)\nrouter.replace(location).then(onComplete).catch(onAbort)\n"
	},
	"VueRouter navigate to named routes without pushing a new history entry": {
		"prefix": "routerReplaceNamedRoute",
		"body": [
			"${5:this.\\$}router.replace({",
			"\tname: ${1:'${2:routename}'},",
			"\tparams: { ${3:property}: ${4:'value'} },",
			"});"
		],
		"description": "Router navigate to named routes without pushing a new history entry.\n#syntax:\nrouter.replace(location, onComplete?, onAbort?)\nrouter.push(location).then(onComplete).catch(onAbort)\n"
	},

	"VueRouter Programmatically navigate to a new URL: go(n)": {
		"prefix": "routerGo",
		"body": ["${2:this.\\$}router.go('${1:n}');"],
		"description": "This method takes a single integer as parameter that indicates by how many steps to go forwards or go backwards in the history stack.\n"
	},
	"VueRouter Programmatically navigate to a new URL: back()": {
		"prefix": "routerBack",
		"body": ["${2:this.\\$}router.back();"],
		"description": "go backwards in the history stack.\n"
	},
	"VueRouter Programmatically navigate to a new URL: forward()": {
		"prefix": "routerForward",
		"body": ["${2:this.\\$}router.forward();"],
		"description": "go forwards in the history stack.\n"
	},
	"VueRouter Reverse URL resolving": {
		"prefix": "routerResolve",
		"body": ["router.resolve(to, current, append);"],
		"description": "Given location in form same as used in `<router-link/>`.\n"
	},

	"VueRouter Global Before Guards": {
		"prefix": ["routerBeforeEach", "guardGlobalBefore"],
		"body": [
			"router.beforeEach((to, from, next) => {",
			"\t/* must call `next` */",
			"\t$0",
			"});"
		],
		"description": "register global before guards.\n`beforeEach(callback(to, from, next))`\n"
	},
	"VueRouter Global Resolve Guards": {
		"prefix": ["routerBeforeResolve", "guardGlobalResolve"],
		"body": [
			"router.beforeResolve((to, from, next) => {",
			"\t/* must call `next` */",
			"\t$0",
			"});"
		],
		"description": "register global resolve guards.\n`beforeResolve(callback(to, from, next))`\n"
	},
	"VueRouter Global After Hooks": {
		"prefix": "routerAfterEach",
		"body": [
			"router.afterEach((to, from) => {",
			"\t$0",
			"});"
		],
		"description": "register global after hooks.\n`afterEach(callback(to, from))`\n"
	},
	"VueRouter Per-Route Guard": {
		"prefix": ["routeBeforeEnter", "guardPerRoute"],
		"body": [
			"beforeEnter((to, from, next) => {",
			"\t/* must call `next` */",
			"\t$0",
			"});"
		],
		"description": "register guards on a route's configuration object.\n`beforeEnter(callback(to, from, next))`\n"
	},
	"VueRouter In-Component Guards": {
		"prefix": ["componentGuards", "guardInComponent"],
		"body": [
			"beforeRouteEnter(to, from, next) {",
			"\tnext((vm) => {$0});",
			"},",
			"beforeRouteUpdate(to, from, next) {",
			"\t// this.name = to.params.name;",
			"\tnext();",
			"},",
			"beforeRouteLeave(to, from, next) {",
			"\tconst answer = window.confirm(",
			"\t\t'Do you really want to leave? you have unsaved changes!'",
			"\t);",
			"\tif (answer) {",
			"\t\tnext();",
			"\t} else {",
			"\t\tnext(false);",
			"\t}",
			"},"
		],
		"description": "define route navigation guards inside route components \n"
	},

	"VueRouter Dynamically add more routes to the router": {
		"prefix": "routerAddRoutes",
		"body": ["router.addRoutes(${1:routes});$0"],
		"description": "The argument must be an Array using the same route config format with the `routes` constructor option.\naddRoutes(routes)\n"
	},

	"VueRouter instance method: onReady(callback, errorCallback)": {
		"prefix": "routerOnReady",
		"body": [
			"router.onReady(${1:callback}, ${2:errorCallback});$0"
		],
		"description": "This method queues a callback to be called when the router has completed the initial navigation, which means it has resolved all async enter hooks and async components that are associated with the initial route.\n"
	},
	"VueRouter instance method: onError(callback)": {
		"prefix": "routerOnError",
		"body": ["router.onError(${1:callback});$0"],
		"description": "Register a callback which will be called when an error is caught during a route navigation. Note for an error to be called, it must be one of the following scenarios:\nThe error is thrown synchronously inside a route guard function;\nThe error is caught and asynchronously handled by calling next(err) inside a route guard function;\nAn error occurred when trying to resolve an async component that is required to render a route.\n"
	},
	"VueRouter instance method: getMatchedComponents(to)": {
		"prefix": "routerGetMatchedComponents",
		"body": ["router.getMatchedComponents(to);"],
		"description": "Returns an Array of the components (definition/constructor, not instances) matched by the provided location or the current route. This is mostly used during server-side rendering to perform data prefetching.\n"
	},

	"VueRouter $route.path": {
		"prefix": "this.$route.path",
		"body": ["this.\\$route.path"],
		"description": "A string that equals the path of the current route, always resolved as an absolute path.\n"
	},
	"VueRouter $route.params": {
		"prefix": ["this.$route.params", "rp"],
		"body": ["this.\\$route.params"],
		"description": "An object that contains key/value pairs of dynamic segments and star segments. If there are no params the value will be an empty object.\n"
	},
	"VueRouter $route.query": {
		"prefix": ["this.$route.query", "rq"],
		"body": ["this.\\$route.query"],
		"description": "An object that contains key/value pairs of the query string.\n"
	},
	"VueRouter $route.hash": {
		"prefix": ["this.$route.hash", "rh"],
		"body": ["this.\\$route.hash"],
		"description": "The hash of the current route (with the #), if it has one. If no hash is present the value will be an empty string.\n"
	},
	"VueRouter $route.fullPath": {
		"prefix": "this.$route.fullPath",
		"body": ["this.\\$route.fullPath"],
		"description": "The full resolved URL including query and hash.\n"
	},
	"VueRouter $route.matched": {
		"prefix": "this.$route.matched",
		"body": ["this.\\$route.matched"],
		"description": "An Array containing route records for all nested path segments of the current route. \n"
	},
	"VueRouter $route.name": {
		"prefix": "this.$route.name",
		"body": ["this.\\$route.name"],
		"description": "The name of the current route, if it has one.\n"
	},
	"VueRouter $route.redirectedFrom": {
		"prefix": "this.$route.redirectedFrom",
		"body": ["this.\\$route.redirectedFrom"],
		"description": "The name of the route being redirected from, if there were one.\n"
	},

	"VueRouter Lazy Loading Routes": {
		"prefix": "lazyRoute",
		"body": [
			"const ${1} = () => import('@/${2:features}/${1:Feature}.vue');$0"
		]
	},
	"VueRouter Lazy Loading Routes, Grouping Components in the Same Chunk": {
		"prefix": "lazyRouteChunk",
		"body": [
			"const ${1:Feature1} = () => import(/* webpackChunkName: \"${3:feature}\" */ '${4:.}/${1}.vue');",
			"const ${2:Feature2} = () => import(/* webpackChunkName: \"${3}\" */ '${5:.}/${2}.vue');"
		]
	},
	"VueRouter Fetching After Navigation": {
		"prefix": "fetchingAfterNavigation",
		"body": [
			"export default {",
			"\tdata() {",
			"\t\treturn {",
			"\t\t\tloading: false,",
			"\t\t\tpost: null,",
			"\t\t\terror: null,",
			"\t\t};",
			"\t},",
			"\tcreated() {",
			"\t\t// fetch the data when the view is created and the data is",
			"\t\t// already being observed",
			"\t\tthis.fetchData();",
			"\t},",
			"\twatch: {",
			"\t\t// call again the method if the route changes",
			"\t\t\\$route: 'fetchData',",
			"\t},",
			"\tmethods: {",
			"\t\tfetchData() {",
			"\t\t\tthis.error = this.post = null;",
			"\t\t\tthis.loading = true;",
			"\t\t\tconst fetchedId = this.\\$route.params.id;",
			"\t\t\t// data fetching util / API wrapper",
			"\t\t\t${1:getPost}(fetchedId, (err, post) => {",
			"\t\t\t\t// make sure this request is the last one we did, discard otherwise",
			"\t\t\t\tif (this.\\$route.params.id !== fetchedId) return;",
			"\t\t\t\tthis.loading = false;",
			"\t\t\t\tif (err) {",
			"\t\t\t\t\tthis.error = err.toString();",
			"\t\t\t\t} else {",
			"\t\t\t\t\tthis.post = post;",
			"\t\t\t\t}",
			"\t\t\t});",
			"\t\t},",
			"\t},",
			"};"
		],
		"description": "fetch data in the component's created hook.\n"
	},
	"VueRouter Fetching Before Navigation": {
		"prefix": "fetchingBeforeNavigation",
		"body": [
			"export default {",
			"\tdata() {",
			"\t\treturn {",
			"\t\t\tpost: null,",
			"\t\t\terror: null,",
			"\t\t};",
			"\t},",
			"\tbeforeRouteEnter(to, from, next) {",
			"\t\t${1:getPost}(to.params.id, (err, post) => {",
			"\t\t\tnext((vm) => vm.setData(err, post));",
			"\t\t});",
			"\t},",
			"\t// when route changes and this component is already rendered,",
			"\t// the logic will be slightly different.",
			"\tbeforeRouteUpdate(to, from, next) {",
			"\t\tthis.post = null;",
			"\t\t${1}(to.params.id, (err, post) => {",
			"\t\t\tthis.setData(err, post);",
			"\t\t\tnext();",
			"\t\t});",
			"\t},",
			"\tmethods: {",
			"\t\tsetData(err, post) {",
			"\t\t\tif (err) {",
			"\t\t\t\tthis.error = err.toString();",
			"\t\t\t} else {",
			"\t\t\t\tthis.post = post;",
			"\t\t\t}",
			"\t\t},",
			"\t},",
			"};"
		],
		"description": "fetch the data before actually navigating to the new route.\n"
	},

	"VueRouter Route-Based Dynamic Transition": {
		"prefix": "routeTransition",
		"body": [
			"watch: {",
			"\t\\$route(to, from) {",
			"\t\tconst toDepth = to.path.split('/').length;",
			"\t\tconst fromDepth = from.path.split('/').length;",
			"\t\tthis.${1:transitionName} = toDepth < fromDepth ? 'slide-right' : 'slide-left';",
			"\t},",
			"},"
		]
	},

	"VueRouter scrollBehavior": {
		"prefix": "vScrollbehavior",
		"body": [
			"scrollBehavior(to, from, savedPosition) {",
			"\tif(savedPosition) {",
			"\t\treturn savedPosition;",
			"\t} else {",
			"\t\treturn { x: 0, y: 0 };",
			"\t}",
			"},"
		],
		"description": "Vue Router scrollBehavior\n"
	}
}
