{
	"this.$watch()": {
		"prefix": "this.$watch(data, cb)",
		"body": [
			"var ${3:unwatch} = this.\\$watch('${1:propertyName}', function (newValue, oldValue) {",
			"  $2",
			"});"
		],
		"description": "Watch an expression or a computed function on the Vue instance for changes. The callback gets called with the new value and the old value. The expression only accepts dot-delimited paths. For more complex expressions, use a function instead.\nVue 3.x Watch on Arrays need add the `deep` property."
	},
	"this.$watch(data, cb, {deep, immediate})": {
		"prefix": "this.$watch(data, cb, {deep, immediate})",
		"body": [
			"var ${4:unwatch} = this.\\$watch('${1:propertyName}', function (newValue, oldValue) {",
			"  $2",
			"}, {",
			"  deep: true,",
			"  ${3:immediate: true,}",
			"});"
		],
		"description": "1. To also detect nested value changes inside Objects, you need to pass in `deep: true` in the options argument. Note that you donâ€™t need to do so to listen for Array mutations. \n2. Passing in `immediate: true` in the option will trigger the callback immediately with the current value of the expression.\nVue 3.x Watch on Arrays need add the `deep` property."
	},
	"this.$set()": {
		"prefix": ["this.$set()", "set"],
		"body": [
			"this.\\$set(this.${1:object/array}, ${2:propertyName/index}, ${3:value});$0"
		],
		"description": "This is the alias of the global Vue.set."
	},
	"this.$delete()": {
		"prefix": "this.$delete()",
		"body": [
			"this.\\$delete(this.${1:object/array}, ${2:propertyName/index}, ${3:value});$0"
		],
		"description": "This is the alias of the global Vue.delete."
	}
}
