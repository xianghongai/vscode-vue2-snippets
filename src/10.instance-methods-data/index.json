{
	"Vue Instance Methods/Data this.$watch()": {
		"prefix": "this.$watch(data, cb)",
		"body": [
			"var ${5:unwatch} = ${1:this}.\\$watch('${2:propertyName}', function (newValue, oldValue) {",
			"  $4",
			"});"
		],
		"description": "Watch an expression or a computed function on the Vue instance for changes. The callback gets called with the new value and the old value. The expression only accepts dot-delimited paths. For more complex expressions, use a function instead.\nVue 3.x Watch on Arrays need add the `deep` property.\n"
	},
	"Vue Instance Methods/Data this.$watch(data, cb, {deep, immediate})": {
		"prefix": "this.$watch(data, cb, {deep, immediate})",
		"body": [
			"var ${5:unwatch} = ${1:this}.\\$watch('${2:propertyName}', function (newValue, oldValue) {",
			"  $3",
			"}, ",
			"{",
			"  deep: true,",
			"  ${4:immediate: true,}",
			"});"
		],
		"description": "1. To also detect nested value changes inside Objects, you need to pass in `deep: true` in the options argument. Note that you donâ€™t need to do so to listen for Array mutations. \n2. Passing in `immediate: true` in the option will trigger the callback immediately with the current value of the expression.\nVue 3.x Watch on Arrays need add the `deep` property.\n"
	},
	"Vue Instance Methods/Data this.$set()": {
		"prefix": [
			"this.$set()",
			"set"
		],
		"body": [
			"${1:this}.\\$set(this.${2:object/array}, ${3:propertyName/index}, ${4:value});$0"
		],
		"description": "This is the alias of the global Vue.set.\n"
	},
	"Vue Instance Methods/Data this.$delete()": {
		"prefix": "this.$delete()",
		"body": [
			"${1:this}.\\$delete(this.${2:object/array}, ${3:propertyName/index}, ${4:value});$0"
		],
		"description": "This is the alias of the global Vue.delete.\n"
	}
}
